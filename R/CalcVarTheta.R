###
#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param theta Coefficeint vector from main PH model. Fist coefficent corresponds to `X`, the rest to `Z`
#' @param tm PARAM_DESCRIPTION
#' @param event Vector of censoring indicators. \code{1} for event \code{0} for censored
#' @param Z Additional variables for the main model other than the binary covaraite
#' @param Q Matrix of covariates for PH calibration model
#' @param ps A matrix. Rows are observations, columns are time points of the events. $ps(i,j)=Pr(X_i(time of case j)=1|history)$
#' @param ps.deriv A matrix. Rows are observations, columns are time points of the events. $ps.deriv(i,j)$ is the derivative of Pr(X_i(time of case j)=1|history)
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @param fit.cox The result of \code{icenReg::ic_sp} on the interval-censored data
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @seealso 
#'  \code{\link[MASS]{ginv}}
#' @rdname CalcVarParam
#' @export 
#' @importFrom MASS ginv
CalcVarParam <- function(theta,  tm, event, Z, Q, ps, ps.deriv, w, w.res, fit.cox)
{
  n <- length(tm)
  n.theta <- length(theta) 
  eta.b <- fit.cox$b
  eta.g <- fit.cox$g
  hessian.eta <- fit.cox$Hessian
  order <- fit.cox$order
  knots <- fit.cox$knots
  n.eta <- length(eta.b) + length(eta.g)
  nabla.eta.Utheta <- matrix(nr = n.theta, nc = n.eta, 0)
  for (i in 1:n.eta)
  {
    nabla.eta.Utheta[1,i] <- CalcNablabeetaUbeta(theta = theta, tm = tm, event = event, ps = ps, Z = Z, psDeriv = t(ps.deriv[,i,]) )
    nabla.eta.Utheta[2:n.theta,i] <- CalcNablabeetaUgamma(theta = theta, tm = tm, event = event, ps = ps, Z = Z, psDeriv = t(ps.deriv[,i,]))
  }
  nabla.eta.Utheta <- nabla.eta.Utheta/n
  ### Prep for calculating gradient of eta
  
  lr.for.fit.raw <- as.data.frame(FindIntervalCalibCPP(w = w, wres = w.res))
  Qinter <- as.matrix(Q[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf), ])
  lr.for.fit <- lr.for.fit.raw[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf), ]
  d1 <- lr.for.fit[,1]==0
  d3 <- lr.for.fit[,2]==Inf
  d2 <- 1 - d1 - d3
  
  ######
  grad.eta.pers.mat <- matrix(nr = n, nc = n.eta,0)
  grad.eta.pers.mat[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf), ] <- CalcGradEtaPers(d1 = d1, d2 = d2, d3 = d3, Li = lr.for.fit[,1],
                                       Ri = lr.for.fit[,2], knots = knots, order = order, eta.g = eta.g, eta.b = eta.b, Q = Qinter)
  b.mat <- CalcbZ(theta = theta, tm = tm, event = event, ps = ps, Z = Z)
  r.mat <- b.mat - t(nabla.eta.Utheta%*%MASS::ginv(hessian.eta)%*%t(grad.eta.pers.mat))
  MM <- array(dim = c(ncol(r.mat),ncol(r.mat),nrow(r.mat)),0)
  for (j in 1:nrow(r.mat))
  {
    MM[,,j] <- r.mat[j,]%*%t(r.mat[j,])
  } 
  meat <- apply(MM, c(1,2), mean)
  bread <- solve(CoxLogLikHess(theta = theta, tm = tm, event = event, ps = ps, Z = Z))
  v.hat <- n*bread%*%meat%*%bread
  if(max(v.hat)>1) {
    for (j in 1:nrow(b.mat))
    {
      MM[,,j] <- b.mat[j, ]%*%t(b.mat[j, ])
    } 
  }
  meat <- apply(MM,c(1,2),mean)
  v.hat <- n*bread%*%meat%*%bread
  return(v.hat)
}

#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param theta Coefficeint vector from main PH model. Fist coefficent corresponds to `X`, the rest to `Z`
#' @param tm PARAM_DESCRIPTION
#' @param event Vector of censoring indicators. \code{1} for event \code{0} for censored
#' @param Z Additional variables for the main model other than the binary covaraite
#' @param Q Matrix of covariates for PH calibration model
#' @param ps A matrix. Rows are observations, columns are time points of the events. $ps(i,j)=Pr(X_i(time of case j)=1|history)$
#' @param ps.deriv A matrix. Rows are observations, columns are time points of the events. $ps.deriv(i,j)$ is the derivative of Pr(X_i(time of case j)=1|history)
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @param fit.cox.rs.ints The result of \code{FitCalibCoxRSInts} on the interval-censored data
#' @param pts.for.ints Points defining the intervals for grouping risk-sets (first one has to be zero). Should be sorted from zero up
#' @param n.etas.per.fit PARAM_DESCRIPTION
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @seealso 
#'  \code{\link[MASS]{ginv}}
#' @rdname CalcVarParamRSInts
#' @export 
#' @importFrom MASS ginv
CalcVarParamRSInts <- function(theta,  tm, event, Z, Q, ps, ps.deriv, w, w.res,  fit.cox.rs.ints,  pts.for.ints, n.etas.per.fit)
{
  n <- length(tm)
  n.theta <- length(theta) 
  n.fits <- length(fit.cox.rs.ints)
  n.eta <- sum(n.etas.per.fit)
  hessian.eta <- matrix(nr = n.eta, nc = n.eta, 0)
  nabla.eta.Utheta <- matrix(nr = n.theta, nc = n.eta, 0)
  for (j in 1:n.fits)
  {
    point <- pts.for.ints[j]
    n.pars.ints <- n.etas.per.fit[j]
    fit.temp.ints <- fit.cox.rs.ints[[j]]
    if (j > 1)
    {hessian.eta[(sum(n.etas.per.fit[1:(j-1)]) + 1):(sum(n.etas.per.fit[1:j])), 
                (sum(n.etas.per.fit[1:(j-1)]) + 1):(sum(n.etas.per.fit[1:j]))] <- fit.temp.ints$Hessian
    } else {
      hessian.eta[1:n.etas.per.fit[j], 1:n.etas.per.fit[j]] <- fit.temp.ints$Hessian
    }
    
    in.risk.set <- tm >= point
    tm.ints <- tm[in.risk.set]
    event.ints <- event[in.risk.set]
    ps.ints <- ps[ ,in.risk.set]
    Z.ints <- Z[in.risk.set,]
    ps.deriv.ints <- ps.deriv[in.risk.set,,]
    for (i in 1:n.pars.ints)
    {
      if (j>1) {param.index <- sum(n.etas.per.fit[1:(j-1)]) + i} else {param.index <- i}
      nabla.eta.Utheta[1, param.index] <- CalcNablabeetaUbeta(theta = theta, tm = tm.ints, event = event.ints, ps = ps.ints, Z = Z.ints, 
                                                   psDeriv = t(ps.deriv.ints[, param.index, ]) )
      nabla.eta.Utheta[2:n.theta, param.index] <- CalcNablabeetaUgamma(theta = theta, tm = tm.ints, event = event.ints, ps = ps.ints, 
                                                                       Z = Z.ints, psDeriv = t(ps.deriv.ints[, param.index, ]))  
    }
    
  }
  nabla.eta.Utheta <- nabla.eta.Utheta/n
  ### Prep for calculating gradient of eta
  
  lr.for.fit.raw <- as.data.frame(FindIntervalCalibCPP(w = w, wres = w.res))
  Qinter <- as.matrix(Q[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf), ])
  tm.inter <- tm[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf)] 
  lr.for.fit <- lr.for.fit.raw[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf), ]
  d1 <- lr.for.fit[,1]==0
  d3 <- lr.for.fit[,2]==Inf
  d2 <- 1 - d1 - d3
  
  ######
  grad.eta.pers.mat <- matrix(nr = n, nc = n.eta,0)
  grad.eta.pers.mat[!(lr.for.fit.raw[,1]==0 & lr.for.fit.raw[,2]==Inf), ] <- CalcGradEtaPersRSInts(d1 = d1, d2 = d2, d3 = d3, 
                                                                                                   Li = lr.for.fit[,1], Ri = lr.for.fit[,2], 
                                                                                                   Q = Qinter, 
                                                                                                   fit.cox.rs.ints = fit.cox.rs.ints,
                                                                                                   pts.for.ints = pts.for.ints, tm = tm.inter, 
                                                                                                   n.etas.per.fit = n.etas.per.fit)
    #CalcGradEtaPersRSInts(d1 = d1, d2 = d2, d3 = d3, Li = lr.for.fit[,1], Ri = lr.for.fit[,2], knots = knots, 
    #order = order, eta.g = eta.g, eta.b = eta.b, Z = Zinter)
  b.mat <- CalcbZ(theta = theta, tm = tm, event = event, ps = ps, Z = Z)
  r.mat <- b.mat - t(nabla.eta.Utheta%*%MASS::ginv(hessian.eta)%*%t(grad.eta.pers.mat))
  MM <- array(dim = c(ncol(r.mat),ncol(r.mat),nrow(r.mat)),0)
  for (j in 1:nrow(r.mat))
  {
    MM[,,j] <- r.mat[j,]%*%t(r.mat[j,])
  } 
  meat <- apply(MM, c(1,2), mean)
  bread <- solve(CoxLogLikHess(theta = theta, tm = tm, event = event, ps = ps, Z = Z))
  v.hat <- n*bread%*%meat%*%bread
  if(max(v.hat)>1) {
    for (j in 1:nrow(b.mat))
    {
      MM[,,j] <- b.mat[j, ]%*%t(b.mat[j, ])
    } 
  }
  meat <- apply(MM,c(1,2),mean)
  v.hat <- n*bread%*%meat%*%bread
  return(v.hat)
}


## Weibull, no extra covariates ###
#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param beta Coefficient of the binary covariate
#' @param etas PARAM_DESCRIPTION
#' @param tm PARAM_DESCRIPTION
#' @param event Vector of censoring indicators. \code{1} for event \code{0} for censored
#' @param ps A matrix. Rows are observations, columns are time points of the events. $ps(i,j)=Pr(X_i(time of case j)=1|history)$
#' @param ps.deriv.shape Same as `ps.deriv.scale` but for the shape parameter
#' @param ps.deriv.scale A matrix. Rows are observations, columns are time points of the events. $ps.deriv.scale(i,j)$ is the derivative
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @seealso 
#'  \code{\link[numDeriv]{hessian}}
#' @rdname CalcVarThetaWeib
#' @export 
#' @importFrom numDeriv hessian
CalcVarThetaWeib <- function(beta, etas, tm, event, ps, ps.deriv.shape, ps.deriv.scale, w, w.res)
{
  n <- length(tm)
  b.vec <- Calcb(beta = beta, tm = tm, event = event, ps = ps)
  nabla.eta.shape.Ubeta <- CalcUbetabeeta(beta = beta, tm = tm, event = event, ps = ps, psDeriv = ps.deriv.shape)
  nabla.eta.scale.Ubeta <- CalcUbetabeeta(beta = beta, tm = tm, event = event, ps = ps, psDeriv = ps.deriv.scale)
  nabla.eta.Ubeta <- c(nabla.eta.shape.Ubeta, nabla.eta.scale.Ubeta)/n
  hess.etas.l.v <- (numDeriv::hessian(func = ICweibLik, x = etas, w = w, w.res = w.res))
  grad.eta.pers <- ICweibGrad(etas = etas, w = w, w.res = w.res)
  r.vec <- b.vec - nabla.eta.Ubeta%*%solve(hess.etas.l.v)%*%t(grad.eta.pers)
  meat <- mean(r.vec^2)  # since beta is one-dimensional here 
  bread <- myFmyHess(beta, tm, event, ps)/n
  var.beta <- (meat/(bread^2))/n
  return(var.beta)
}
#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param beta Coefficient of the binary covariate
#' @param etas.matrix PARAM_DESCRIPTION
#' @param tm PARAM_DESCRIPTION
#' @param event Vector of censoring indicators. \code{1} for event \code{0} for censored
#' @param ps.rs PARAM_DESCRIPTION
#' @param ps.deriv.shape.rs Same as `ps.deriv.scale` but for the risk-set shape parameters
#' @param ps.deriv.scale.rs A matrix. Rows are observations, columns are time points of the events. $ps.deriv(i,j)$ is the derivative
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname CalcVarThetaWeibRS
#' @export 
CalcVarThetaWeibRS <- function(beta, etas.matrix, tm, event, ps.rs, ps.deriv.shape.rs, ps.deriv.scale.rs, w, w.res)
{
  n <- length(tm)
  b.vec <- Calcb(beta = beta, tm = tm, event = event, ps = ps.rs)
  nabla.etas.shape.Ubeta <- CalcUbetabeetaRS(beta = beta, tm = tm, event = event, ps = ps.rs, psDeriv = ps.deriv.shape.rs)
  nabla.etas.scale.Ubeta <- CalcUbetabeetaRS(beta = beta, tm = tm, event = event, ps = ps.rs, psDeriv = ps.deriv.scale.rs)
  nabla.etas.Ubeta <- c(rbind(nabla.etas.shape.Ubeta, nabla.etas.scale.Ubeta))/n

  hess.eta.inv <- ICweibHessSolvedRS(etas.matrix = etas.matrix, w = w, w.res = w.res, tm = tm, event = event)
  grad.eta.pers <- ICweibGradRS(etas = etas.matrix, w = w, w.res = w.res,  tm = tm, event = event)
   r.vec <- b.vec - nabla.etas.Ubeta%*%hess.eta.inv%*%t(grad.eta.pers)
  meat <- mean(r.vec^2)  # since beta is one-dimensional here 
  bread <- myFmyHess(beta, tm, event, ps.rs)/n
  var.beta <- (meat/(bread^2))/n
  return(var.beta)
}
#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param etas PARAM_DESCRIPTION
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @seealso 
#'  \code{\link[numDeriv]{hessian}}
#' @rdname CalcVarEta
#' @export 
#' @importFrom numDeriv hessian
CalcVarEta <- function(etas,  w, w.res)
{
  n <- nrow(w)
  hess.etas.l.v <- (numDeriv::hessian(func = ICweibLik, x = etas, w = w, w.res = w.res))
  grad.eta.pers <- ICweibGrad(etas = etas, w = w, w.res = w.res)
  grad.eta <- 0
  for (j in 1:nrow(grad.eta.pers))
  {
    grad.eta <- grad.eta + grad.eta.pers[j,]%*%t(grad.eta.pers[j,])
  }    
  var.eta <-  solve(hess.etas.l.v)%*%(grad.eta)%*%solve(hess.etas.l.v)
    return(var.eta)
}
#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param tm PARAM_DESCRIPTION
#' @param event Vector of censoring indicators. \code{1} for event \code{0} for censored
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @param BS Number of bootstrap iterations, Default: 100
#' @param CI PARAM_DESCRIPTION, Default: T
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname CalcVarNpmle
#' @export 
CalcVarNpmle <- function(tm, event, w, w.res, BS = 100, CI = T)
{
  n <- length(tm)
  beta.np.calib.bs <- vector(length = BS)
  for (j in 1:BS)
  {
    indices <- sample.int(n = n, size = n, replace = T)
    tm.bs <- tm[indices]
    event.bs <- event[indices]
    case.times.bs <- tm.bs[event.bs==1]
    w.bs <- w[indices,]
    w.res.bs <- w.res[indices,]
    fit.npmle.bs <- FitCalibNpmle(w = w.bs, w.res = w.res.bs)
    px.np.bs <- t(sapply(case.times.bs, CalcNpmleCalibP, w = w.bs, w.res =  w.res.bs, fit.npmle = fit.npmle.bs))
    px.np.bs[is.na(px.np.bs)] <- 0 # To avoid very rare errors
    beta.np.calib.bs[j] <- optimize(f = CoxLogLikX,  tm = tm.bs, event = event.bs, ps = px.np.bs, 
                             interval = c(-50,50), maximum = T)$maximum
  }
  v.hat.npmle <- var(beta.np.calib.bs[abs(beta.np.calib.bs) < 5])
  if (CI ==T)
  {
    ci.l <- quantile(x = beta.np.calib.bs[abs(beta.np.calib.bs) < 5], probs = 0.025)
    ci.h <- quantile(x = beta.np.calib.bs[abs(beta.np.calib.bs) < 5], probs = 0.975)
    return(list(v = v.hat.npmle, ci = c(ci.l, ci.h)))
  } else{
    return(list(v = v.hat.npmle))
}}
#' @title FUNCTION_TITLE
#' @description FUNCTION_DESCRIPTION
#' @param tm PARAM_DESCRIPTION
#' @param event Vector of censoring indicators. \code{1} for event \code{0} for censored
#' @param w A matrix of time points when measurements on the binary covariate were obtained.
#' @param w.res A matrix of measurement results of the binary covariate. Each measurement corresponds to the time points in \code{w}
#' @param BS Number of bootstrap iterations, Default: 100
#' @param CI PARAM_DESCRIPTION, Default: T
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #EXAMPLE1
#'  }
#' }
#' @rdname CalcVarNpmleRS
#' @export 
CalcVarNpmleRS <- function(tm, event, w, w.res, BS = 100, CI =T)
{
  n <- length(tm)
  beta.np.calib.rs.bs <- vector(length = BS)
  for (j in 1:BS)
  {
    #  cat("j = ", j)
    indices <- sample.int(n = n, size = n, replace = T)
    tm.bs <- tm[indices]
    event.bs <- event[indices]
    case.times.bs <- tm.bs[event.bs==1]
    w.bs <- w[indices,]
    w.res.bs <- w.res[indices,]
    px.np.rs.bs <- t(sapply(case.times.bs, CalcNpmleRSP, w = w.bs, w.res =  w.res.bs, obs.tm = tm.bs))
    px.np.rs.bs[is.na(px.np.rs.bs)] <- 0 # To avoid very rare errors
    beta.np.calib.rs.bs[j] <- optimize(f = CoxLogLikX,  tm = tm.bs, event = event.bs, ps = px.np.rs.bs, 
                                    interval = c(-50,50), maximum = T)$maximum
  }
  v.hat.npmle.rs <- var(beta.np.calib.rs.bs[abs(beta.np.calib.rs.bs) < 5])
  if (CI ==T)
  {
    ci.l <- quantile(x = beta.np.calib.rs.bs[abs(beta.np.calib.rs.bs) < 5], probs = 0.025)
    ci.h <- quantile(x = beta.np.calib.rs.bs[abs(beta.np.calib.rs.bs) < 5], probs = 0.975)
    return(list(v = v.hat.npmle.rs, ci = c(ci.l, ci.h)))
  } else{
    return(list(v = v.hat.npmle.rs))
}}

# CalcVarThetaCox <- function(beta, etas, tm, event, ps, ps.deriv.shape, ps.deriv.scale, w, w.res)
# {
#   n <- length(tm)
#   b.vec <- Calcb(beta = beta, tm = tm, event = event, ps = ps)
#   nabla.eta.shape.Ubeta <- CalcUbetabeeta(beta = beta, tm = tm, event = event, ps = ps, psDeriv = ps.deriv.shape)
#   nabla.eta.scale.Ubeta <- CalcUbetabeeta(beta = beta, tm = tm, event = event, ps = ps, psDeriv = ps.deriv.scale)
#   nabla.eta.Ubeta <- c(nabla.eta.shape.Ubeta, nabla.eta.scale.Ubeta)/n
#   hess.etas.l.v <- (hessian(func = ICweibLik, x = etas, w = w, w.res = w.res))
#   grad.eta.pers <- ICweibGrad(etas = etas, w = w, w.res = w.res)
#   r.vec <- b.vec - nabla.eta.Ubeta%*%solve(hess.etas.l.v)%*%t(grad.eta.pers)
#   meat <- mean(r.vec^2)  # since beta is one-dimensional here 
#   bread <- myFmyHess(beta, tm, event, ps)/n
#   var.beta <- (meat/(bread^2))/n
#   return(var.beta)
# }
# 
# CalcVarThetaCoxRS <- function(beta, etas.matrix, tm, event, ps.rs, ps.deriv.shape.rs, ps.deriv.scale.rs, w, w.res)
# {
#   n <- length(tm)
#   b.vec <- Calcb(beta = beta, tm = tm, event = event, ps = ps.rs)
#   nabla.etas.shape.Ubeta <- CalcUbetabeetaRS(beta = beta, tm = tm, event = event, ps = ps.rs, psDeriv = ps.deriv.shape.rs)
#   nabla.etas.scale.Ubeta <- CalcUbetabeetaRS(beta = beta, tm = tm, event = event, ps = ps.rs, psDeriv = ps.deriv.scale.rs)
#   nabla.etas.Ubeta <- c(rbind(nabla.etas.shape.Ubeta, nabla.etas.scale.Ubeta))/n
#   
#   hess.eta.inv <- ICweibHessSolvedRS(etas.matrix = etas.matrix, w = w, w.res = w.res, tm = tm, event = event)
#   grad.eta.pers <- ICweibGradRS(etas = etas.matrix, w = w, w.res = w.res,  tm = tm, event = event)
#   r.vec <- b.vec - nabla.etas.Ubeta%*%hess.eta.inv%*%t(grad.eta.pers)
#   meat <- mean(r.vec^2)  # since beta is one-dimensional here 
#   bread <- myFmyHess(beta, tm, event, ps.rs)/n
#   var.beta <- (meat/(bread^2))/n
#   return(var.beta)
# }
